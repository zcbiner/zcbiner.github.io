---
title: 线性排序
date: 2018-07-27 18:15:36
tags: 算法
---

> 本文梳理总结线性排序。介绍桶排序、计数排序、基数排序的原理，并给出代码示例。

<!--more-->

### 前言

线性排序算法就三个：

- 桶排序

- 计数排序

- 基数排序

**线性排序算法的时间复杂度为O(n)**。线性排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。

### 一、桶排序

#### 1.原理

1. 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序（或者归并排序）。

2. 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

#### 2.适用条件

1. 要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序。

2. 数据在各个桶之间分布是均匀的。

#### 3.代码实例

假设数据：[1,7,8,24,19,46,26,38,33,12,42,20,6,35]，使用桶排序。

观察发现，这里可以分为5个桶，分别标号为：0，1，2，3，4，这5个桶，0号放小于10的数，1号放大于等于10小于20的数，依次类推。

将数字放到不同的桶里后，桶里可以使用快速排序。

代码实现：

```python
def sort(arr):
    # 将数据分到5个桶中
    buckets = [[],[],[],[],[]]
    for index in range(len(arr)):
        bucket_no = arr[index] // 10
        buckets[bucket_no].append(arr[index])
    
    # 桶内数据排序
    for index in range(len(buckets)):
        buckets[index].sort()
        print(buckets[index])

if __name__ == '__main__':
    arr = [1,7,8,24,19,46,26,38,33,12,42,20,6,35]
    sort(arr)
```

运行结果：

```
[1, 6, 7, 8]
[12, 19]
[20, 24, 26]
[33, 35, 38]
[42, 46]
```

#### 4.应用案例

1. 需求描述：

有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB。

2. 解决思路：

扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。

第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。

每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。

将100个小文件依次放入内存并用快排排序。

所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。

注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。

#### 5.时间复杂度

我们假设有n个待排序数字。分到m个桶中，如果分配均匀这样平均每个桶有n/m个元素。桶排序的算法时间复杂度有两部分组成：

1. 遍历处理每个元素，O(n)级别的普通遍历

2. 每个桶内再次排序的时间复杂度总和

这里看桶内排序总的时间复杂度：

如果桶内元素分配较为均匀假设每个桶内部使用的排序算法为快速排序，那么每个桶内的时间复杂度为(n/m)log(n/m)。有m个桶，那么时间复杂度为m * (n/m)log(n/m)=n(log(n)-log(m))。

所以总的时间复杂度为:O(n)+n(log(n)-log(m))。当n与m趋近与相等时，时间复杂度即为O(n)

### 二、计数排序

#### 1.原理

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

其实可以将计数排序看做是特殊的桶排序。如果要排序n个数据，其最大值为k，那么创建0-k的桶进行排序，省去了桶内排序的时间。

#### 2.代码实例

假设要给数据排序：[2,5,3,0,2,3,0,3]。其最大值为5，那么创建5个桶，特别注意的是，**桶中存放的不是实际的数据，而是对应的数有几个**。

比如0号桶里的值为2，因为数据0有两个。

所以将数据处理到桶中后，桶里的数据变为：[2,0,2,3,0,1]，为何3号桶里数据为3？是因为原数据里有3个3。所以这种排序方法才叫计数排序，因为桶里存放的不是实际数据，而是对应数据的个数。

桶里计数完后就可以进行排序了吗？不是。为了保证排序的稳定性，还需要对桶里的数据进行处理：将每个桶的数加上它之前所有桶的数。也就是说3号桶的数据变为2+0+2+3=7。

此时桶里的数据为：[2,2,4,7,7,8]。

最后，创建一个辅助数组表示排序后的数据。从后向前扫描原数据，比如第一次取到的数据为3，3号桶的数据为7，所以数据3需要放到辅助数组的7号位置。依次类推。

代码实现：

```python
def sort(arr, max):
    # 0-5共6个桶
    buckets = [0]*(max+1)
    # 统计每个桶应该有几个数
    for index in range(len(arr)):
        # 计数
        buckets[arr[index]] += 1
    
    # 累加
    for i in range(1, max + 1):
        buckets[i] = buckets[i] + buckets[i - 1]
    
    sortarr = [0]*len(arr)
    for data in reversed(arr):
        # 桶里存放的是data的个数，算出来的index为在排序后数组里的位置
        index = buckets[data] - 1
        sortarr[index] = data
        buckets[data] -= 1
    
    print(sortarr)


if __name__ == '__main__':
    arr = [2,5,3,0,2,3,0,3]
    sort(arr, 5)
```

#### 3.复杂度分析

n为排序数据的个数，k为最大值。

- 最坏时间复杂度：O(n+k)

- 最优时间复杂度：O(n+k)

- 平均时间复杂度：O(n+k)；非常稳定

- 空间复杂度：O(n+k)；也有极端情况，当数组中最大值远小于数组中元素的数量，空间这时候会被运用得很有效率，O(k).

#### 4.适用场景

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。

而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

### 三、基数排序

是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

#### 1.原理

基数排序适用于排序不同位数的大小数字（也可以转换为不同位数的字符串等）。

这里拿一个具体数列举例：[26,3,49,556,81,9,863,0]。

由于个位数肯定是0-9的范围，因此创建0-9号桶。

第一轮，根据个位数分别放到桶中，此时桶中数据为：[0,81,-,[3,863],-,-,[26,556],-,-,[49,9]]。然后按个位数大小取出排序，

此时数列数据为：[0,81,3,863,26,556,49,9]。

第二轮，根据十位数分别放到桶中，此时桶中数据为：[[0,3,9],-,[26],-,[49],[556],[863],-,[81],-]。然后按十位数大小取出排序，

此时数列数据为：[0,3,9,26,49,556,863,81]。

第三轮，根据百位数分别放到桶中，此时桶中数据为：[[0,3,9,26,49,81],-,-,-,-,[556],-,-,[863],-]。然后按十位数大小取出排序，

此时数列数据为：[0,3,9,26,49,81,556,863]。

排序完成。

#### 2.代码实例

使用基数排序完成：[26,3,49,556,81,9,863,0]数列的排序。

代码实现：

```python
def sort(arr, max):
    for i in range(max):
        # 0-9共10个桶
        buckets = [-1]*10
        for j in range(len(arr)):
            data = arr[j]
            if i > 0:
                data = data // 10
            index = data % 10
            if buckets[index] == -1:
                buckets[index] = [arr[j]]
            else :
                buckets[index].append(arr[j])
        # 从桶里取出数据排序
        print(buckets)
        k = 0
        for j in range(len(buckets)):
            temp_list = buckets[j]
            if temp_list != -1:
                for l in range(len(temp_list)):
                    arr[k] = temp_list[l]
                    k += 1
        print(arr)

if __name__ == '__main__':
    arr = [26,3,49,556,81,9,863,0]
    sort(arr, 3)
```

两个print打印出来的值为：

```
[[0], [81], -1, [3, 863], -1, -1, [26, 556], -1, -1, [49, 9]]

[0, 81, 3, 863, 26, 556, 49, 9]


[[0, 3, 9], -1, [26], -1, [49], [556], [863], -1, [81], -1]

[0, 3, 9, 26, 49, 556, 863, 81]


[[0, 3, 9], -1, [26], -1, [49], [556], [863], -1, [81], -1]

[0, 3, 9, 26, 49, 556, 863, 81]
```



从打印出来的值可以很好的看出基数排序的过程。